import unittest
import ast
from engine.ast_parser import *

def sample_optimisation(ast_parser, node):
    """
    An optimisation helper function that modifies AST nodes for testing.
    If the node is an assignment (ast.Assign), change the value of the assignment to 42.
    """
    if isinstance(node, ast.Assign):
        for target in node.targets:
            if isinstance(target, ast.Name) and target.id == "x":
                node.value = ast.Constant(value=42) # Modify value to 42

class TestASTParser(unittest.TestCase):
    def setUp(self):
        """
        Set up common variables and resources needed for tests.
        """
        self.valid_code = "x = 10\nprint(x)"
        self.invalid_code = "x = 10\nprint(x"  # missing parenthesis
        self.parser = ASTParser(self.valid_code)

    def test_parse_ast_valid_code(self):
        """
        Test the parse_ast method with valid Python code.
        
        Checks that the parse_ast method of Class ASTParser returns a ast.AST tree and valid code doesn't raise an error.
        
        Assertions:
            - The returned tree is an instance of ast.AST
        """
        parser = self.parser
        tree = parser.parse_ast(self.valid_code)
        self.assertIsInstance(tree, ast.AST)
        
    def test_parse_ast_invalid_code_raises_syntaxerror(self):
        """
        Test the parse_ast method with invalid Python code.
        
        Checks that syntactically incorrect code raises a SyntaxError
        
        Assertions:
            - The parse_ast method raises a SyntaxError
        """
        with self.assertRaises(SyntaxError):
            self.parser.parse_ast(self.invalid_code)
            
    def test_walk_and_apply(self):
        """
        Test the `walk_and_apply` method of the parser.
        
        This test verifies that the `walk_and_apply` method correctly modifies the AST (Abstract Syntax Tree)
        by applying the sample_optimisation function. It checks that the original code and the modified code
        are not equal and that the modified code has the expected value.
        
        Assertions:
            - The original code and modified code should not be equal.
            - The modified code should have a value of 42.
        """
        
        # Arrange
        parser = self.parser
        original_code = parser.tree.body[0].value
        # Act
        self.parser.walk_and_apply(sample_optimisation)
        modified_code = parser.tree.body[0].value
        # Assert
        self.assertNotEqual(original_code, modified_code)
        self.assertEqual(modified_code.n, 42) # 42 == 42

    def test_get_node_source(self):
        """
        Test the `get_node_source` method of the parser.
        
        This test verifies that the `get_node_source` method correctly retrieves
        the source code of a given AST node. Specifically, it checks that the
        assignment "x = 10" is returned accurately.
        
        Assertions:
            - The source code of the first node should be "x = 10".
        """
        parser = self.parser
        tree = parser.tree
        node = tree.body[0]  # Get the first node (x = 10)
        
        source = parser.get_node_source(node)
        
        self.assertEqual(source, "x = 10")
    
    def test_get_source(self):
        """
        Test the `get_source` method of the parser.

        This test checks if the source code regenerated by the parser matches the 
        expected valid code.

        Assertions:
            - The regenerated code is the same as the original valid code.
        """
        regenerated_code = self.parser.get_source()        
        self.assertEqual(regenerated_code.strip(), self.valid_code.strip())
        

    # def test_visualise_ast(self):
    #     # Optional manual test
    #     sample_code = "x = 10\nprint(x)"
    #     tree = parse_ast(sample_code)
    #     self.assertIsNotNone(tree)
    #     try:
    #         visualise_ast(tree)
    #     except Exception as e:
    #         self.fail(f"visualise_ast raised an exception: {e}")

if __name__ == "__main__":
    unittest.main()